@apiKey = {{$dotenv DEEPSEEK_API_KEY}}
@baseUrl = http://localhost:5000
@ytVideo = https://www.youtube.com/watch?v=zQnBQ4tB3ZA

### Summarize YouTube Video
POST {{baseUrl}}/summarize/video
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
    "content": {
      "text": "Transcript: TypeScript. Validate your JavaScript ahead of time with static type checking. JavaScript is a dynamic language where we can do all kinds of crazy things, like reference variables that don't exist or work with objects of an unknown shape. The code is interpreted by a browser, but if your code is 
broken, you won't catch it until runtime, when the browser throws an error. TypeScript prevents errors like this from ever happening by extending JavaScript with types. The language is a strict superset of JavaScript, which means when you open up a TS file, you can write plain JavaScript with all of its extra features being completely optional. But notice in the code here how the IDE is providing feedback about using a variable that doesn't exist. Instead of fixing this issue weeks later in a stack trace after the company has lost millions of dollars, we can fix it right here, right now. The reason we get this instant feedback is because TypeScript behaves like a compiled language, where JavaScript is the compilation target. You can run the TypeScript compiler using the tsc command. It will take the TS file and transpile it into vanilla JavaScript, and you can choose any flavor of JavaScript you want if you need to target ancient browsers. And that means you can use the latest and greatest syntax features of JavaScript without having to worry if they'll be supported in an older environment. Your TypeScript project will likely have a tsconfig file, which provides an infinite number of ways to customize the behavior of the compiler. But the primary goal of TypeScript is to enable static typing. One way it achieves that is by allowing you to annotate your code with types. We can strongly type a variable using a colon followed by its type, like a string, boolean, or number. That's known as an explicit type. If we then 
try to assign its value as the wrong type, we get an error. Alternatively, if we set an initial value, it will implicitly infer the type. However, there may be cases where you want to opt out of this behavior, in which case you can annotate with the any type. That allows you to loosely type or opt out of type checking. When working with an array, use brackets to strongly type a list. In addition, you can define your own custom types and interfaces, which is 
especially powerful when working with objects. The char interface here defines various types of the properties on an object. We can then apply the interface to a plain JavaScript object. The beauty of having strongly typed code is that we get autocomplete everywhere in our IDE. We don't have to jump back and forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
azy things, like reference variables that don't exist or work with objects of an unknown shape. The code is interpreted by a browser, but if your code is 
broken, you won't catch it until runtime, when the browser throws an error. TypeScript prevents errors like this from ever happening by extending JavaScript with types. The language is a strict superset of JavaScript, which means when you open up a TS file, you can write plain JavaScript with all of its extra features being completely optional. But notice in the code here how the IDE is providing feedback about using a variable that doesn't exist. Instead of fixing this issue weeks later in a stack trace after the company has lost millions of dollars, we can fix it right here, right now. The reason we get this instant feedback is because TypeScript behaves like a compiled language, where JavaScript is the compilation target. You can run the TypeScript compiler using the tsc command. It will take the TS file and transpile it into vanilla JavaScript, and you can choose any flavor of JavaScript you want if you need to target ancient browsers. And that means you can use the latest and greatest syntax features of JavaScript without having to worry if they'll be supported in an older environment. Your TypeScript project will likely have a tsconfig file, which provides an infinite number of ways to customize the behavior of the compiler. But the primary goal of TypeScript is to enable static typing. One way it achieves that is by allowing you to annotate your code with types. We can strongly type a variable using a colon followed by its type, like a string, boolean, or number. That's known as an explicit type. If we then 
try to assign its value as the wrong type, we get an error. Alternatively, if we set an initial value, it will implicitly infer the type. However, there may be cases where you want to opt out of this behavior, in which case you can annotate with the any type. That allows you to loosely type or opt out of type checking. When working with an array, use brackets to strongly type a list. In addition, you can define your own custom types and interfaces, which is 
especially powerful when working with objects. The char interface here defines various types of the properties on an object. We can then apply the interface to a plain JavaScript object. The beauty of having strongly typed code is that we get autocomplete everywhere in our IDE. We don't have to jump back and forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
 fixing this issue weeks later in a stack trace after the company has lost millions of dollars, we can fix it right here, right now. The reason we get this instant feedback is because TypeScript behaves like a compiled language, where JavaScript is the compilation target. You can run the TypeScript compiler using the tsc command. It will take the TS file and transpile it into vanilla JavaScript, and you can choose any flavor of JavaScript you want if you need to target ancient browsers. And that means you can use the latest and greatest syntax features of JavaScript without having to worry if they'll be supported in an older environment. Your TypeScript project will likely have a tsconfig file, which provides an infinite number of ways to customize the behavior of the compiler. But the primary goal of TypeScript is to enable static typing. One way it achieves that is by allowing you to annotate your code with types. We can strongly type a variable using a colon followed by its type, like a string, boolean, or number. That's known as an explicit type. If we then 
try to assign its value as the wrong type, we get an error. Alternatively, if we set an initial value, it will implicitly infer the type. However, there may be cases where you want to opt out of this behavior, in which case you can annotate with the any type. That allows you to loosely type or opt out of type checking. When working with an array, use brackets to strongly type a list. In addition, you can define your own custom types and interfaces, which is 
especially powerful when working with objects. The char interface here defines various types of the properties on an object. We can then apply the interface to a plain JavaScript object. The beauty of having strongly typed code is that we get autocomplete everywhere in our IDE. We don't have to jump back and forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
r of the compiler. But the primary goal of TypeScript is to enable static typing. One way it achieves that is by allowing you to annotate your code with types. We can strongly type a variable using a colon followed by its type, like a string, boolean, or number. That's known as an explicit type. If we then 
try to assign its value as the wrong type, we get an error. Alternatively, if we set an initial value, it will implicitly infer the type. However, there may be cases where you want to opt out of this behavior, in which case you can annotate with the any type. That allows you to loosely type or opt out of type checking. When working with an array, use brackets to strongly type a list. In addition, you can define your own custom types and interfaces, which is 
especially powerful when working with objects. The char interface here defines various types of the properties on an object. We can then apply the interface to a plain JavaScript object. The beauty of having strongly typed code is that we get autocomplete everywhere in our IDE. We don't have to jump back and forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
pe checking. When working with an array, use brackets to strongly type a list. In addition, you can define your own custom types and interfaces, which is 
especially powerful when working with objects. The char interface here defines various types of the properties on an object. We can then apply the interface to a plain JavaScript object. The beauty of having strongly typed code is that we get autocomplete everywhere in our IDE. We don't have to jump back and forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
d forth to documentation or dig through stack traces to figure out why our code's not working. If you like TypeScript as much as I do, consider becoming a pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one.
 pro member at Fireship.io. For the next few days, everything will be 40% off, including lifetime memberships. Thanks for watching, and I will see you in 
the next one."
    }, 
    "options": {
      "model": "deepseek"
    }
}